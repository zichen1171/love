<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <title>跨年粒子舞台</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: "Segoe UI", "PingFang SC", sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<canvas id="particle-stage"></canvas>
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
      }
    }
</script>
<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import {OrbitControls} from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const canvas = document.getElementById('particle-stage');
    const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(90, 95, 140);
    camera.lookAt(0, 35, 0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.enableZoom = true;
    controls.enableRotate = true;
    controls.enablePan = true;

    const positionArray = [];
    const colorArray = [];
    const basePositions = [];
    const amplitudes = [];
    const speedFactors = [];
    const spinOffsets = [];

    function addParticle(x, y, z, amp, speed, customColor = null) {
        positionArray.push(x, y, z);
        basePositions.push(x, y, z);
        const color =
            customColor ||
            new THREE.Color().setHSL(Math.random(), 0.6 + Math.random() * 0.3, 0.5 + Math.random() * 0.3);
        colorArray.push(color.r, color.g, color.b);
        amplitudes.push(amp);
        speedFactors.push(speed);
        spinOffsets.push(Math.random() * Math.PI * 2);
    }

    function getVibrantColor() {
        return new THREE.Color().setHSL(Math.random(), 0.7 + Math.random() * 0.25, 0.5 + Math.random() * 0.35);
    }

    function getHeartColor() {
        const hue = 0.985 + (Math.random() - 0.5) * 0.008;
        const saturation = 0.8 + (Math.random() - 0.5) * 0.015;
        const lightness = 0.56 + (Math.random() - 0.5) * 0.015;
        return new THREE.Color().setHSL(hue, saturation, lightness);
    }

    const platformCount = 6500;
    const platformRadius = 80;
    const platformThickness = 8;
    for (let i = 0; i < platformCount; i++) {
        const radius = platformRadius * Math.sqrt(Math.random());
        const angle = Math.random() * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = (Math.random() - 0.5) * platformThickness;
        addParticle(x, y, z, 0.7 + Math.random() * 0.4, 0.25 + Math.random() * 0.25);
    }

    function heartCurve(t) {
        return {
            x: 16 * Math.pow(Math.sin(t), 3),
            y:
                13 * Math.cos(t) -
                5 * Math.cos(2 * t) -
                2 * Math.cos(3 * t) -
                Math.cos(4 * t)
        };
    }

    const heartMainTotal = Math.floor(6200 * 1.2);
    const heartCoreTotal = Math.floor(1800 * 1.2);
    const heartBlendTotal = Math.floor(2400 * 1.2);
    const heartTotal = heartMainTotal + heartCoreTotal + heartBlendTotal;
const heartScaleX = 1.2;
const heartScaleY = 1.375;
const heartScaleZ = 10.5;
    const heartTimeline = [
        {time: 0, scale: 0.05, pulse: 0, twist: 0, glow: 0.1},
        {time: 2.2, scale: 0.32, pulse: 0.28, twist: 0.2, glow: 0.35},
        {time: 4.8, scale: 0.72, pulse: 0.5, twist: 0.5, glow: 0.65},
        {time: 7.1, scale: 0.95, pulse: 0.75, twist: 0.75, glow: 0.85},
        {time: 9.6, scale: 0.9, pulse: 0.95, twist: 1, glow: 1}
    ];

    for (let i = 0; i < heartMainTotal; i++) {
        const t = Math.random() * Math.PI * 2;
        const distribution = Math.random();
        let radial;
        if (distribution < 0.32) {
            radial = Math.pow(0.6 + Math.random() * 0.4, 0.52);
        } else if (distribution < 0.66) {
            radial = Math.pow(Math.random(), 1.1);
        } else {
            radial = Math.pow(Math.random(), 1.9);
        }
        radial = THREE.MathUtils.clamp(radial, 0.03, 1);
        const {x: baseX, y: baseY} = heartCurve(t);
        const contourFactor = 1 - radial;
        const soften = THREE.MathUtils.smootherstep(radial, 0, 1);
        const fillBoost = Math.pow(1 - radial, 1.2);
        const jitterScale = 0.55 + fillBoost * 0.35;
        const x =
            baseX * radial * heartScaleX +
            (Math.random() - 0.5) * contourFactor * 0.55 * jitterScale;
        const y =
            baseY * radial * heartScaleY +
            34 +
            (Math.random() - 0.5) * contourFactor * 0.75 * jitterScale +
            THREE.MathUtils.lerp(0, 1.15, radial);
        const arcProfile = Math.sin((1 - Math.pow(radial, 0.8)) * Math.PI * 0.58);
        const depthRange = THREE.MathUtils.lerp(0.9, 4.1, arcProfile);
        const depth =
            Math.sin((Math.random() - 0.5) * Math.PI) * depthRange * heartScaleZ * 0.13 +
            (Math.random() - 0.5) * contourFactor * 0.45;
        const heartColor = getHeartColor();
        addParticle(
            x,
            y,
            depth * (heartScaleZ / 10),
            1.7 + Math.random() * 0.9,
            0.6 + Math.random() * 0.35,
            heartColor
        );
    }

    for (let i = 0; i < heartBlendTotal; i++) {
        const t = Math.random() * Math.PI * 2;
        const radial = THREE.MathUtils.lerp(0.42 + Math.random() * 0.4, 0.96, Math.pow(Math.random(), 1.15));
        const {x: baseX, y: baseY} = heartCurve(t);
        const contourFactor = 1 - radial;
        const jitterClamp = THREE.MathUtils.lerp(0.32, 0.16, radial);
        const x =
            baseX * radial * heartScaleX +
            (Math.random() - 0.5) * contourFactor * 0.55 * jitterClamp;
        const y =
            baseY * radial * heartScaleY +
            34 +
            (Math.random() - 0.5) * contourFactor * 0.65 * jitterClamp +
            THREE.MathUtils.lerp(0.2, 0.95, radial);
        const arcProfile = Math.sin((1 - Math.pow(radial, 0.9)) * Math.PI * 0.58);
        const depthRange = THREE.MathUtils.lerp(1, 4.2, arcProfile);
        const depth =
            Math.sin((Math.random() - 0.5) * Math.PI) * depthRange * heartScaleZ * 0.13 +
            (Math.random() - 0.5) * contourFactor * 0.4;
        const blendColor = getHeartColor();
        addParticle(
            x,
            y,
            depth * (heartScaleZ / 10),
            1.72 + Math.random() * 0.85,
            0.58 + Math.random() * 0.32,
            blendColor
        );
    }

    for (let i = 0; i < heartCoreTotal; i++) {
        const t = Math.random() * Math.PI * 2;
        const radial = 0.18 + Math.pow(Math.random(), 1.35) * 0.82;
        const {x: baseX, y: baseY} = heartCurve(t);
        const contourFactor = 1 - radial;
        const jitterEnvelope = 0.35 + Math.random() * 0.25;
        const x =
            baseX * radial * heartScaleX * (0.94 + Math.random() * 0.05) +
            (Math.random() - 0.5) * jitterEnvelope * 0.55;
        const y =
            baseY * radial * heartScaleY * (0.93 + Math.random() * 0.07) +
            34 +
            Math.sin(t * 1.8) * 0.65 +
            (Math.random() - 0.5) * jitterEnvelope * 0.55;
        const arcProfile = Math.pow(1 - radial, 0.85);
        const depthRange = THREE.MathUtils.lerp(1.1, 4.4, arcProfile);
        const depth =
            Math.sin((Math.random() - 0.5) * Math.PI) * depthRange * heartScaleZ * 0.15 +
            (Math.random() - 0.5) * contourFactor * 0.35;
        const coreColor = getHeartColor();
        addParticle(
            x,
            y,
            depth * (heartScaleZ / 10),
            1.85 + Math.random() * 1.05,
            0.58 + Math.random() * 0.4,
            coreColor
        );
    }

    const cubeCount = 2500;
    const cubeSize = 63;
    const cubeHeight = 71;
    const cubeThickness = 8;
    const cubeHalfThickness = cubeThickness / 2;
    for (let i = 0; i < cubeCount; i++) {
        const face = i % 6;
        let x = (Math.random() - 0.5) * cubeSize * 2;
        let y = cubeHeight + (Math.random() - 0.5) * cubeThickness;
        let z = (Math.random() - 0.5) * cubeSize * 2;
        if (face === 0) x = cubeSize;
        if (face === 1) x = -cubeSize;
        if (face === 2) y = cubeHeight + cubeHalfThickness;
        if (face === 3) y = cubeHeight - cubeHalfThickness;
        if (face === 4) z = cubeSize;
        if (face === 5) z = -cubeSize;
        addParticle(x, y, z, 1.4 + Math.random() * 0.6, 0.5 + Math.random() * 0.3);
    }

    const particleCount = positionArray.length / 3;
    const positions = new Float32Array(positionArray);
    const colors = new Float32Array(colorArray);
    const basePos = new Float32Array(basePositions);
    const amps = new Float32Array(amplitudes);
    const speeds = new Float32Array(speedFactors);
    const spins = new Float32Array(spinOffsets);

    const platformLength = platformCount * 3;
    const heartOffset = platformLength;
    const heartRangeEnd = heartOffset + heartTotal * 3;
    const cubeOffset = heartRangeEnd;
    const cubeLength = cubeCount * 3;
    const heartCenter = new THREE.Vector3(0, 34, 0);
    const heartGrowthDuration = heartTimeline[heartTimeline.length - 1].time;

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    function createCircleTexture() {
        const size = 64;
        const circle = document.createElement('canvas');
        circle.width = size;
        circle.height = size;
        const ctx = circle.getContext('2d');
        const gradient = ctx.createRadialGradient(size / 2, size / 2, size * 0.1, size / 2, size / 2, size * 0.5);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
        const texture = new THREE.CanvasTexture(circle);
        texture.minFilter = THREE.LinearFilter;
        return texture;
    }

    const circleTexture = createCircleTexture();

    const material = new THREE.PointsMaterial({
        size: 1,
        map: circleTexture,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        opacity: 0.8,
        alphaTest: 0.15,
        blending: THREE.NormalBlending
    });
    const mainParticles = new THREE.Points(geometry, material);
    scene.add(mainParticles);

    const starGeometry = new THREE.BufferGeometry();
    const starCount = 7200;
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
        starPositions[i * 3] = (Math.random() - 0.5) * 900;
        starPositions[i * 3 + 1] = (Math.random() - 0.5) * 900;
        starPositions[i * 3 + 2] = (Math.random() - 0.5) * 900;
        const starColor = getVibrantColor();
        starColors[i * 3] = starColor.r;
        starColors[i * 3 + 1] = starColor.g;
        starColors[i * 3 + 2] = starColor.b;
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    const starMaterial = new THREE.PointsMaterial({
        size: 1.15,
        map: circleTexture,
        vertexColors: true,
        transparent: true,
        opacity: 0.55,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    const swirlGroup = new THREE.Group();
    scene.add(swirlGroup);
    const swirlRibbons = [];
    const ribbonBaseColor = new THREE.Color();
    const ribbonGradientColor = new THREE.Color();
    const ribbonHSL = {h: 0, s: 0, l: 0};

    function createSwirlRibbon({
                                   radius,
                                   loops,
                                   color,
                                   speed,
                                   phase = 0,
                                   opacity = 0.8,
                                   tilt = 0.6,
                                   verticalLoops = 1.6,
                                   verticalSpeed = 0.22,
                                   wrapRadius = 18,
                                   hueRange = 0.22,
                                   sparkleSize = 5,
                                   noiseAmplitude = 5
                               }) {
        const segments = 320;
        const positions = new Float32Array((segments + 1) * 3);
        const colors = new Float32Array((segments + 1) * 3);
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity,
            blending: THREE.AdditiveBlending
        });
        const line = new THREE.Line(geometry, material);
        swirlGroup.add(line);
        const spark = new THREE.Sprite(
            new THREE.SpriteMaterial({
                map: circleTexture,
                color: color || 0xffffff,
                transparent: true,
                opacity: 0.35,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            })
        );
        spark.scale.set(sparkleSize * 0.8, sparkleSize * 0.8, 1);
        swirlGroup.add(spark);
        const baseColor = color ? ribbonBaseColor.set(color) : getVibrantColor();
        baseColor.getHSL(ribbonHSL);
        swirlRibbons.push({
            line,
            geometry,
            segments,
            baseRadius: radius,
            loops,
            speed,
            phase,
            tilt,
            verticalLoops,
            verticalSpeed,
            wrapRadius,
            colorAttr: geometry.getAttribute('color'),
            hue: ribbonHSL.h,
            saturation: ribbonHSL.s,
            lightness: ribbonHSL.l,
            hueRange,
            spark,
            sparkleSize,
            sparklePhase: Math.random(),
            noiseAmplitude
        });
    }

    createSwirlRibbon({
        radius: 70,
        loops: 3.2,
        color: getVibrantColor(),
        speed: 0.2,
        tilt: 0.7,
        wrapRadius: 24,
        sparkleSize: 6,
        noiseAmplitude: 7
    });
    createSwirlRibbon({
        radius: 58,
        loops: 3.8,
        color: getVibrantColor(),
        speed: 0.28,
        phase: Math.PI / 3,
        tilt: 0.8,
        verticalLoops: 2,
        wrapRadius: 22,
        sparkleSize: 5,
        noiseAmplitude: 6
    });
    createSwirlRibbon({
        radius: 80,
        loops: 2.8,
        color: getVibrantColor(),
        speed: 0.18,
        phase: Math.PI / 1.5,
        tilt: 0.65,
        verticalLoops: 1.4,
        wrapRadius: 28,
        sparkleSize: 7,
        noiseAmplitude: 8
    });
    createSwirlRibbon({
        radius: 92,
        loops: 4.1,
        color: getVibrantColor(),
        speed: 0.24,
        phase: Math.PI / 2.4,
        tilt: 0.55,
        verticalLoops: 1.2,
        wrapRadius: 34,
        sparkleSize: 8,
        noiseAmplitude: 9
    });
    createSwirlRibbon({
        radius: 48,
        loops: 4.6,
        color: getVibrantColor(),
        speed: 0.32,
        phase: Math.PI / 1.1,
        tilt: 0.9,
        verticalLoops: 2.4,
        wrapRadius: 18,
        sparkleSize: 5,
        noiseAmplitude: 5.5
    });

    const haloCount = 1600;
    const haloPositions = new Float32Array(haloCount * 3);
    const haloColors = new Float32Array(haloCount * 3);
    const haloData = [];
    for (let i = 0; i < haloCount; i++) {
        const radius = 32 + Math.random() * 42;
        const height = -10 + Math.random() * 28;
        const phase = Math.random() * Math.PI * 2;
        const speed = 0.08 + Math.random() * 0.22;
        haloData.push({radius, height, phase, speed, sway: 1 + Math.random() * 2.2});
        const color = new THREE.Color().setHSL(0.85 + Math.random() * 0.1, 0.75, 0.62 + Math.random() * 0.1);
        haloColors[i * 3] = color.r;
        haloColors[i * 3 + 1] = color.g;
        haloColors[i * 3 + 2] = color.b;
        haloPositions[i * 3] = 0;
        haloPositions[i * 3 + 1] = 0;
        haloPositions[i * 3 + 2] = 0;
    }
    const haloGeometry = new THREE.BufferGeometry();
    haloGeometry.setAttribute('position', new THREE.BufferAttribute(haloPositions, 3));
    haloGeometry.setAttribute('color', new THREE.BufferAttribute(haloColors, 3));
    const haloMaterial = new THREE.PointsMaterial({
        size: 1.1,
        map: circleTexture,
        vertexColors: true,
        transparent: true,
        opacity: 0.75,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    const haloParticles = new THREE.Points(haloGeometry, haloMaterial);
    scene.add(haloParticles);

    const burstCount = 520;
    const burstPositions = new Float32Array(burstCount * 3);
    const burstColors = new Float32Array(burstCount * 3);
    const burstData = [];
    const burstBaseColors = [];
    for (let i = 0; i < burstCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const offset = Math.random() * 5;
        const duration = 2.5 + Math.random() * 3.5;
        const maxRadius = 12 + Math.random() * 35;
        const heightRange = 4 + Math.random() * 10;
        burstData.push({angle, offset, duration, maxRadius, heightRange});
        const color = new THREE.Color().setHSL(0.82 + Math.random() * 0.12, 0.9, 0.6 + Math.random() * 0.2);
        burstBaseColors.push(color);
        burstPositions[i * 3] = 0;
        burstPositions[i * 3 + 1] = 0;
        burstPositions[i * 3 + 2] = 0;
        burstColors[i * 3] = 0;
        burstColors[i * 3 + 1] = 0;
        burstColors[i * 3 + 2] = 0;
    }
    const burstGeometry = new THREE.BufferGeometry();
    burstGeometry.setAttribute('position', new THREE.BufferAttribute(burstPositions, 3));
    burstGeometry.setAttribute('color', new THREE.BufferAttribute(burstColors, 3));
    const burstMaterial = new THREE.PointsMaterial({
        size: 1.65,
        map: circleTexture,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    const burstParticles = new THREE.Points(burstGeometry, burstMaterial);
    scene.add(burstParticles);

    const heartGlow = new THREE.Sprite(
        new THREE.SpriteMaterial({
            map: circleTexture,
            color: 0xff4a6e,
            transparent: true,
            opacity: 0.18,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        })
    );
    heartGlow.scale.set(100, 100, 1);
    heartGlow.position.copy(heartCenter);
    scene.add(heartGlow);

    const swirlParticleCount = 900;
    const swirlParticlePositions = new Float32Array(swirlParticleCount * 3);
    const swirlParticleColors = new Float32Array(swirlParticleCount * 3);
    const swirlParticleData = [];
    const swirlTempColor = new THREE.Color();
    for (let i = 0; i < swirlParticleCount; i++) {
        const radius = 45 + Math.random() * 45;
        const angle = Math.random() * Math.PI * 2;
        const height = heartCenter.y - 6 + Math.random() * 20;
        const delay = 1.2 + Math.random() * 3.2;
        const absorbTime = 3.2 + Math.random() * 3.5;
        const speed = 0.35 + Math.random() * 0.25;
        const hue = Math.random();
        const saturation = 0.6 + Math.random() * 0.3;
        const lightness = 0.45 + Math.random() * 0.35;
        const orbitFactor = THREE.MathUtils.clamp((radius - 50) / 40, 0, 1);
        swirlParticleData.push({
            radius,
            angle,
            height,
            delay,
            absorbTime,
            speed,
            hue,
            saturation,
            lightness,
            orbitFactor
        });
        const color = new THREE.Color().setHSL(hue, saturation, lightness);
        swirlParticleColors[i * 3] = color.r;
        swirlParticleColors[i * 3 + 1] = color.g;
        swirlParticleColors[i * 3 + 2] = color.b;
        swirlParticlePositions[i * 3] = Math.cos(angle) * radius;
        swirlParticlePositions[i * 3 + 1] = height;
        swirlParticlePositions[i * 3 + 2] = Math.sin(angle) * radius;
    }
    const swirlParticleGeometry = new THREE.BufferGeometry();
    swirlParticleGeometry.setAttribute('position', new THREE.BufferAttribute(swirlParticlePositions, 3));
    swirlParticleGeometry.setAttribute('color', new THREE.BufferAttribute(swirlParticleColors, 3));
const swirlParticleMaterial = new THREE.PointsMaterial({
    size: 0.8,
        map: circleTexture,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });
    const swirlParticles = new THREE.Points(swirlParticleGeometry, swirlParticleMaterial);
    scene.add(swirlParticles);

    const clock = new THREE.Clock();
    let previousElapsed = 0;

    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    function sampleTimelineValue(timeline, time, key) {
        if (time <= timeline[0].time) {
            return timeline[0][key];
        }
        const last = timeline[timeline.length - 1];
        if (time >= last.time) {
            return last[key];
        }
        for (let i = 0; i < timeline.length - 1; i++) {
            const current = timeline[i];
            const next = timeline[i + 1];
            if (time >= current.time && time <= next.time) {
                const span = (time - current.time) / (next.time - current.time);
                return THREE.MathUtils.lerp(current[key], next[key], easeOutCubic(span));
            }
        }
        return timeline[timeline.length - 1][key];
    }

    function animate() {
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();
        const delta = elapsed - previousElapsed;
        previousElapsed = elapsed;
        const posAttr = geometry.getAttribute('position');
        const arr = posAttr.array;
        const growth = Math.min(1, elapsed / heartGrowthDuration);
        const easedGrowth = easeOutCubic(growth);
        const stageScale = sampleTimelineValue(heartTimeline, elapsed, 'scale');
        const pulseStrength = sampleTimelineValue(heartTimeline, elapsed, 'pulse');
        const twistStrength = sampleTimelineValue(heartTimeline, elapsed, 'twist');
        const glowStrength = sampleTimelineValue(heartTimeline, elapsed, 'glow');
        const pulseOsc = Math.sin(elapsed * (1.3 + pulseStrength * 1.6));
        const heartScaleFactor = stageScale + pulseOsc * 0.03 * (0.6 + pulseStrength);
        const waveAmplitude = 0.35 + pulseStrength * 1.15;
        const twistGlobal = Math.sin(elapsed * 0.35) * 0.28 * twistStrength;
        for (let i = 0; i < particleCount; i++) {
            const idx = i * 3;
            const phase = elapsed * speeds[i] + spins[i];
            arr[idx] = basePos[idx] + Math.cos(phase) * 0.25 * (i < platformCount ? 0.7 : 1.4);
            arr[idx + 1] = basePos[idx + 1] + Math.sin(phase) * amps[i];
            arr[idx + 2] = basePos[idx + 2] + Math.sin(phase * 0.9) * 0.25 * (i < platformCount ? 0.4 : 1.1);
        }
        for (let i = heartOffset; i < heartRangeEnd; i += 3) {
            const cx = arr[i] - heartCenter.x;
            const cy = arr[i + 1] - heartCenter.y;
            const cz = arr[i + 2] - heartCenter.z;
            const length = Math.sqrt(cx * cx + cy * cy + cz * cz) || 1;
            const twistAngle = twistGlobal + (cy / 60) * twistStrength * 0.8;
            const cosTwist = Math.cos(twistAngle);
            const sinTwist = Math.sin(twistAngle);
            const rotatedX = cx * cosTwist - cz * sinTwist;
            const rotatedZ = cx * sinTwist + cz * cosTwist;
            const wave = Math.sin(length * 0.12 + elapsed * (2 + pulseStrength)) * waveAmplitude;
            arr[i] =
                heartCenter.x +
                rotatedX * heartScaleFactor +
                (rotatedX / length) * wave * 0.6;
            arr[i + 1] =
                heartCenter.y +
                cy * heartScaleFactor +
                Math.sin(elapsed * 1.5 + length * 0.08) * 0.45 * pulseStrength;
            arr[i + 2] =
                heartCenter.z +
                rotatedZ * heartScaleFactor +
                (rotatedZ / length) * wave * 0.6;
        }
        const rotationSpeed = elapsed * 0.06;
        for (let i = 0; i < platformLength; i += 3) {
            const x = basePos[i];
            const z = basePos[i + 2];
            arr[i] = x * Math.cos(rotationSpeed) - z * Math.sin(rotationSpeed);
            arr[i + 2] = x * Math.sin(rotationSpeed) + z * Math.cos(rotationSpeed);
        }
        const rotationSpeedCube = elapsed * 0.075;
        for (let i = cubeOffset; i < cubeOffset + cubeLength; i += 3) {
            const x = basePos[i];
            const z = basePos[i + 2];
            arr[i] = x * Math.cos(rotationSpeedCube) - z * Math.sin(rotationSpeedCube);
            arr[i + 2] = x * Math.sin(rotationSpeedCube) + z * Math.cos(rotationSpeedCube);
        }
        const absorbPhase = Math.max(0, easedGrowth - 0.2);
        swirlRibbons.forEach((ribbon) => {
            const {
                line,
                geometry,
                segments,
                baseRadius,
                loops,
                speed,
                phase,
                tilt,
                verticalLoops,
                verticalSpeed,
                wrapRadius,
                colorAttr,
                hue,
                saturation,
                lightness,
                hueRange,
                spark,
                sparkleSize,
                sparklePhase,
                noiseAmplitude
            } = ribbon;
            const posAttrRibbon = geometry.getAttribute('position');
            const colorAttrRibbon = colorAttr;
            const sparkIndex = Math.floor(
                (((elapsed * (speed * 0.4 + 0.05)) + sparklePhase) % 1) * segments
            );
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const azimuth = phase + t * loops * Math.PI * 2 + elapsed * speed;
                const polar =
                    Math.sin(t * verticalLoops * Math.PI + elapsed * verticalSpeed) * tilt * (Math.PI / 2);
                const cosPolar = Math.cos(polar);
                const sinPolar = Math.sin(polar);
                const noise =
                    Math.sin(t * 14 + elapsed * 2 + phase) * noiseAmplitude * (1 - absorbPhase * 0.55);
                const radius =
                    THREE.MathUtils.lerp(baseRadius, baseRadius * 0.2, absorbPhase) *
                    cosPolar *
                    (0.92 + Math.sin(t * 10 + elapsed * 1.4) * 0.05) +
                    noise;
                const y =
                    heartCenter.y +
                    sinPolar * wrapRadius +
                    Math.sin(azimuth * 0.35 + elapsed * 0.55) * THREE.MathUtils.lerp(1.2, 2.6, absorbPhase);
                const x = Math.cos(azimuth) * radius;
                const z = Math.sin(azimuth) * radius;
                posAttrRibbon.setXYZ(i, x, y, z);
                const gradient = i / segments;
                const hueValue =
                    (hue + gradient * hueRange + elapsed * 0.12 + pulseStrength * 0.25) % 1;
                const satValue = THREE.MathUtils.clamp(saturation + 0.2 + glowStrength * 0.4, 0, 1);
                const lightValue = THREE.MathUtils.clamp(
                    lightness + gradient * 0.4 + glowStrength * 0.3,
                    0,
                    1
                );
                ribbonGradientColor.setHSL(hueValue, satValue, lightValue);
                colorAttrRibbon.setXYZ(i, ribbonGradientColor.r, ribbonGradientColor.g, ribbonGradientColor.b);
                if (i === sparkIndex) {
                    spark.position.set(x, y, z);
                }
            }
            posAttrRibbon.needsUpdate = true;
            colorAttrRibbon.needsUpdate = true;
            const sparkScale = sparkleSize * (0.35 + glowStrength * 0.6);
            spark.scale.set(sparkScale, sparkScale, 1);
            spark.material.opacity = 0.12 + glowStrength * 0.25;
            line.material.opacity =
                0.35 + glowStrength * 0.4 + Math.sin(elapsed * 0.5 + phase) * 0.2;
        });

        const haloAttr = haloGeometry.getAttribute('position');
        for (let i = 0; i < haloCount; i++) {
            const data = haloData[i];
            const orbitAngle = data.phase + elapsed * data.speed + pulseStrength * 0.4;
            const radius =
                data.radius + Math.sin(elapsed * 0.6 + data.phase) * (2 + glowStrength * 12);
            const y =
                heartCenter.y +
                data.height +
                Math.sin(orbitAngle * 2) * data.sway * (0.3 + glowStrength * 0.8);
            haloAttr.setXYZ(i, Math.cos(orbitAngle) * radius, y, Math.sin(orbitAngle) * radius);
        }
        haloAttr.needsUpdate = true;
        haloMaterial.size = 1 + glowStrength * 0.8;
        haloMaterial.opacity = 0.35 + glowStrength * 0.4;

        const burstPosAttr = burstGeometry.getAttribute('position');
        const burstColorAttr = burstGeometry.getAttribute('color');
        for (let i = 0; i < burstCount; i++) {
            const data = burstData[i];
            const localTime = (elapsed + data.offset) % data.duration;
            const progress = localTime / data.duration;
            const radial = THREE.MathUtils.lerp(
                2,
                data.maxRadius,
                easeOutCubic(Math.min(progress * 1.15, 1))
            );
            const radius = radial * (0.6 + glowStrength * 0.6);
            const fade = Math.sin(progress * Math.PI);
            const angle = data.angle + progress * Math.PI * 6 + elapsed * 0.15;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y =
                heartCenter.y +
                Math.cos(progress * Math.PI * 2) * data.heightRange +
                Math.sin(elapsed * 0.7 + data.offset) * 1.2;
            burstPosAttr.setXYZ(i, x, y, z);
            const baseColor = burstBaseColors[i];
            burstColorAttr.setXYZ(i, baseColor.r * fade, baseColor.g * fade, baseColor.b * fade);
        }
        burstPosAttr.needsUpdate = true;
        burstColorAttr.needsUpdate = true;
        burstMaterial.size = 1.4 + glowStrength * 0.9;

        const glowScale = 90 + glowStrength * 80 + Math.sin(elapsed * 1.6) * 8;
        heartGlow.scale.set(glowScale, glowScale, glowScale);
        heartGlow.position.y = heartCenter.y + Math.sin(elapsed * 0.5) * 2;
        heartGlow.material.opacity = 0.08 + glowStrength * 0.18;

        const swirlParticleAttr = swirlParticleGeometry.getAttribute('position');
        const swirlParticleColorAttr = swirlParticleGeometry.getAttribute('color');
        for (let i = 0; i < swirlParticleCount; i++) {
            const {
                radius,
                angle,
                height,
                delay,
                absorbTime,
                speed,
                hue,
                saturation,
                lightness,
                orbitFactor
            } = swirlParticleData[i];
            const life = Math.max(0, elapsed - delay);
            const absorbProgress = THREE.MathUtils.clamp(life / absorbTime, 0, 1);
            const currentRadius =
                THREE.MathUtils.lerp(radius, 3, absorbProgress) * (0.9 + pulseStrength * 0.25);
    const spinStrength = (0.01 + pulseStrength * 0.1) * orbitFactor;
    const absorbTwist = absorbProgress * Math.PI * (2.2 + pulseStrength * 1.1) * orbitFactor;
    const currentAngle =
        orbitFactor <= 0.15 ? angle : angle - elapsed * speed * spinStrength + absorbTwist;
            const currentHeight = THREE.MathUtils.lerp(
                    height,
                    heartCenter.y + 8 + glowStrength * 4,
                    absorbProgress
                ) +
                Math.sin(elapsed * 1.2 + angle) * (1.2 + glowStrength * 0.8);
            swirlParticleAttr.setXYZ(
                i,
                Math.cos(currentAngle) * currentRadius,
                currentHeight,
                Math.sin(currentAngle) * currentRadius
            );
            const animatedHue = (hue + elapsed * 0.08 + pulseStrength * 0.2) % 1;
            const animatedSat = THREE.MathUtils.clamp(saturation + glowStrength * 0.3, 0, 1);
            const animatedLight = THREE.MathUtils.clamp(lightness + glowStrength * 0.35, 0, 1);
            swirlTempColor.setHSL(animatedHue, animatedSat, animatedLight);
            swirlParticleColorAttr.setXYZ(i, swirlTempColor.r, swirlTempColor.g, swirlTempColor.b);
        }
        swirlParticleAttr.needsUpdate = true;
        swirlParticleColorAttr.needsUpdate = true;
        posAttr.needsUpdate = true;
        stars.rotation.y += 0.0003;
        controls.update();
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
